// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.12
// source: manager/manager.proto

package manager1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ManagerWorkClient is the client API for ManagerWork service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ManagerWorkClient interface {
	Create(ctx context.Context, in *CreateWorkRequest, opts ...grpc.CallOption) (*CreateWorkResponse, error)
	Update(ctx context.Context, in *UpdateWorkRequest, opts ...grpc.CallOption) (*UpdateWorkResponse, error)
	GetAll(ctx context.Context, in *GetWorkRequest, opts ...grpc.CallOption) (*GetAllWorkResponse, error)
	GetAllByDate(ctx context.Context, in *GetByDateWorkRequest, opts ...grpc.CallOption) (*GetAllWorkResponse, error)
	Delete(ctx context.Context, in *DeleteWorkRequest, opts ...grpc.CallOption) (*DeleteWorkResponse, error)
}

type managerWorkClient struct {
	cc grpc.ClientConnInterface
}

func NewManagerWorkClient(cc grpc.ClientConnInterface) ManagerWorkClient {
	return &managerWorkClient{cc}
}

func (c *managerWorkClient) Create(ctx context.Context, in *CreateWorkRequest, opts ...grpc.CallOption) (*CreateWorkResponse, error) {
	out := new(CreateWorkResponse)
	err := c.cc.Invoke(ctx, "/manager.ManagerWork/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerWorkClient) Update(ctx context.Context, in *UpdateWorkRequest, opts ...grpc.CallOption) (*UpdateWorkResponse, error) {
	out := new(UpdateWorkResponse)
	err := c.cc.Invoke(ctx, "/manager.ManagerWork/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerWorkClient) GetAll(ctx context.Context, in *GetWorkRequest, opts ...grpc.CallOption) (*GetAllWorkResponse, error) {
	out := new(GetAllWorkResponse)
	err := c.cc.Invoke(ctx, "/manager.ManagerWork/GetAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerWorkClient) GetAllByDate(ctx context.Context, in *GetByDateWorkRequest, opts ...grpc.CallOption) (*GetAllWorkResponse, error) {
	out := new(GetAllWorkResponse)
	err := c.cc.Invoke(ctx, "/manager.ManagerWork/GetAllByDate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerWorkClient) Delete(ctx context.Context, in *DeleteWorkRequest, opts ...grpc.CallOption) (*DeleteWorkResponse, error) {
	out := new(DeleteWorkResponse)
	err := c.cc.Invoke(ctx, "/manager.ManagerWork/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ManagerWorkServer is the server API for ManagerWork service.
// All implementations must embed UnimplementedManagerWorkServer
// for forward compatibility
type ManagerWorkServer interface {
	Create(context.Context, *CreateWorkRequest) (*CreateWorkResponse, error)
	Update(context.Context, *UpdateWorkRequest) (*UpdateWorkResponse, error)
	GetAll(context.Context, *GetWorkRequest) (*GetAllWorkResponse, error)
	GetAllByDate(context.Context, *GetByDateWorkRequest) (*GetAllWorkResponse, error)
	Delete(context.Context, *DeleteWorkRequest) (*DeleteWorkResponse, error)
	mustEmbedUnimplementedManagerWorkServer()
}

// UnimplementedManagerWorkServer must be embedded to have forward compatible implementations.
type UnimplementedManagerWorkServer struct {
}

func (UnimplementedManagerWorkServer) Create(context.Context, *CreateWorkRequest) (*CreateWorkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedManagerWorkServer) Update(context.Context, *UpdateWorkRequest) (*UpdateWorkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedManagerWorkServer) GetAll(context.Context, *GetWorkRequest) (*GetAllWorkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAll not implemented")
}
func (UnimplementedManagerWorkServer) GetAllByDate(context.Context, *GetByDateWorkRequest) (*GetAllWorkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllByDate not implemented")
}
func (UnimplementedManagerWorkServer) Delete(context.Context, *DeleteWorkRequest) (*DeleteWorkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedManagerWorkServer) mustEmbedUnimplementedManagerWorkServer() {}

// UnsafeManagerWorkServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ManagerWorkServer will
// result in compilation errors.
type UnsafeManagerWorkServer interface {
	mustEmbedUnimplementedManagerWorkServer()
}

func RegisterManagerWorkServer(s grpc.ServiceRegistrar, srv ManagerWorkServer) {
	s.RegisterService(&ManagerWork_ServiceDesc, srv)
}

func _ManagerWork_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateWorkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerWorkServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/manager.ManagerWork/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerWorkServer).Create(ctx, req.(*CreateWorkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagerWork_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateWorkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerWorkServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/manager.ManagerWork/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerWorkServer).Update(ctx, req.(*UpdateWorkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagerWork_GetAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWorkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerWorkServer).GetAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/manager.ManagerWork/GetAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerWorkServer).GetAll(ctx, req.(*GetWorkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagerWork_GetAllByDate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByDateWorkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerWorkServer).GetAllByDate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/manager.ManagerWork/GetAllByDate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerWorkServer).GetAllByDate(ctx, req.(*GetByDateWorkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagerWork_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteWorkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerWorkServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/manager.ManagerWork/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerWorkServer).Delete(ctx, req.(*DeleteWorkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ManagerWork_ServiceDesc is the grpc.ServiceDesc for ManagerWork service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ManagerWork_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "manager.ManagerWork",
	HandlerType: (*ManagerWorkServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _ManagerWork_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _ManagerWork_Update_Handler,
		},
		{
			MethodName: "GetAll",
			Handler:    _ManagerWork_GetAll_Handler,
		},
		{
			MethodName: "GetAllByDate",
			Handler:    _ManagerWork_GetAllByDate_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _ManagerWork_Delete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "manager/manager.proto",
}

// ManagerPriceClient is the client API for ManagerPrice service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ManagerPriceClient interface {
	Create(ctx context.Context, in *CreatePriceRequest, opts ...grpc.CallOption) (*CreatePriceResponse, error)
	Update(ctx context.Context, in *UpdatePriceRequest, opts ...grpc.CallOption) (*UpdatePriceResponse, error)
	Get(ctx context.Context, in *GetPriceRequest, opts ...grpc.CallOption) (*GetPriceResponse, error)
}

type managerPriceClient struct {
	cc grpc.ClientConnInterface
}

func NewManagerPriceClient(cc grpc.ClientConnInterface) ManagerPriceClient {
	return &managerPriceClient{cc}
}

func (c *managerPriceClient) Create(ctx context.Context, in *CreatePriceRequest, opts ...grpc.CallOption) (*CreatePriceResponse, error) {
	out := new(CreatePriceResponse)
	err := c.cc.Invoke(ctx, "/manager.ManagerPrice/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerPriceClient) Update(ctx context.Context, in *UpdatePriceRequest, opts ...grpc.CallOption) (*UpdatePriceResponse, error) {
	out := new(UpdatePriceResponse)
	err := c.cc.Invoke(ctx, "/manager.ManagerPrice/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managerPriceClient) Get(ctx context.Context, in *GetPriceRequest, opts ...grpc.CallOption) (*GetPriceResponse, error) {
	out := new(GetPriceResponse)
	err := c.cc.Invoke(ctx, "/manager.ManagerPrice/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ManagerPriceServer is the server API for ManagerPrice service.
// All implementations must embed UnimplementedManagerPriceServer
// for forward compatibility
type ManagerPriceServer interface {
	Create(context.Context, *CreatePriceRequest) (*CreatePriceResponse, error)
	Update(context.Context, *UpdatePriceRequest) (*UpdatePriceResponse, error)
	Get(context.Context, *GetPriceRequest) (*GetPriceResponse, error)
	mustEmbedUnimplementedManagerPriceServer()
}

// UnimplementedManagerPriceServer must be embedded to have forward compatible implementations.
type UnimplementedManagerPriceServer struct {
}

func (UnimplementedManagerPriceServer) Create(context.Context, *CreatePriceRequest) (*CreatePriceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedManagerPriceServer) Update(context.Context, *UpdatePriceRequest) (*UpdatePriceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedManagerPriceServer) Get(context.Context, *GetPriceRequest) (*GetPriceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedManagerPriceServer) mustEmbedUnimplementedManagerPriceServer() {}

// UnsafeManagerPriceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ManagerPriceServer will
// result in compilation errors.
type UnsafeManagerPriceServer interface {
	mustEmbedUnimplementedManagerPriceServer()
}

func RegisterManagerPriceServer(s grpc.ServiceRegistrar, srv ManagerPriceServer) {
	s.RegisterService(&ManagerPrice_ServiceDesc, srv)
}

func _ManagerPrice_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerPriceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/manager.ManagerPrice/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerPriceServer).Create(ctx, req.(*CreatePriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagerPrice_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerPriceServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/manager.ManagerPrice/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerPriceServer).Update(ctx, req.(*UpdatePriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagerPrice_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagerPriceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/manager.ManagerPrice/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagerPriceServer).Get(ctx, req.(*GetPriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ManagerPrice_ServiceDesc is the grpc.ServiceDesc for ManagerPrice service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ManagerPrice_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "manager.ManagerPrice",
	HandlerType: (*ManagerPriceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _ManagerPrice_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _ManagerPrice_Update_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _ManagerPrice_Get_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "manager/manager.proto",
}
